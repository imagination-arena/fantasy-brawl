<html><head><base href="create-fighting-moves.html"><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><style>
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

body {
  font-family: 'Press Start 2P', cursive;
  line-height: 1.6;
  padding: 20px;
  background-color: #2c3e50;
  color: #fff;
  image-rendering: pixelated;
}

h1 {
  color: #fff;
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 2px;
  text-shadow: 2px 2px 0 #ff6b6b, 4px 4px 0 #4ecdc4;
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  padding: 20px;
  font-size: 2.5em;
  background-color: #2c3e50;
  border-radius: 10px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
}

.container {
  display: flex;
  justify-content: space-between;
  max-width: 1000px;
  margin: 0 auto;
  background-color: #34495e;
  padding: 20px;
  border: 4px solid #000;
  box-shadow: 0 0 0 4px #34495e, 0 0 0 8px #000;
  border-radius: 10px;
}

.pixel-editor {
  border: 4px solid #000;
  padding: 20px;
  background-color: #2c3e50;
  border-radius: 8px;
}

#pixel-grid {
  display: grid;
  grid-template-columns: repeat(32, 10px);
  grid-gap: 0;
  margin-bottom: 20px;
}

.pixel {
  width: 10px;
  height: 10px;
  background-color: #000;
  border: none;
}

.tools {
  margin-bottom: 20px;
  display: flex;
  justify-content: space-between;
}

.character-preview {
  border: 4px solid #000;
  padding: 20px;
  width: 300px;
  background-color: #2c3e50;
  border-radius: 8px;
}

input, button {
  width: 100%;
  margin-bottom: 10px;
  padding: 10px;
  border: 2px solid #000;
  background-color: #34495e;
  color: #fff;
  font-family: 'Press Start 2P', cursive;
}

button {
  background-color: #ff6b6b;
  color: #fff;
  border: 2px solid #000;
  cursor: pointer;
  text-transform: uppercase;
}

button:hover {
  background-color: #4ecdc4;
  color: #000;
}

#color-picker {
  height: 40px;
  background-color: transparent;
  border: none;
}

#current-move {
  font-size: 1.2em;
  margin-bottom: 20px;
  text-align: center;
  color: #ff6b6b;
  text-shadow: 2px 2px #000;
}

#character-sprite {
  width: 320px;
  height: 320px;
  margin: 0 auto;
  display: block;
  image-rendering: pixelated;
  border: 4px solid #000;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
}

#finish {
  margin-top: 20px;
  background-color: #4ecdc4;
  color: #000;
}

#finish:hover {
  background-color: #ff6b6b;
  color: #fff;
  border-color: #000;
}
</style>
</head><body>
  <h1>Create Your Fighting Moves</h1>
  <div class="container">
    <div class="pixel-editor">
      <div id="current-move">Current Move: Kick</div>
      <div id="pixel-grid"></div>
      <div class="tools">
        <input type="color" id="color-picker" value="#00ffff">
        <button id="pen">Pen</button>
        <button id="bucket">Bucket</button>
        <button id="eraser">Eraser</button>
        <button id="undo">Undo</button>
      </div>
      <button id="save-frame">Save Move</button>
    </div>
    <div class="character-preview">
      <h2>Your Character</h2>
      <div id="character-sprite"></div>
      <button id="finish">Finish</button>
    </div>
  </div>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const grid = document.getElementById('pixel-grid');
      const colorPicker = document.getElementById('color-picker');
      const penButton = document.getElementById('pen');
      const bucketButton = document.getElementById('bucket');
      const eraserButton = document.getElementById('eraser');
      const undoButton = document.getElementById('undo');
      const saveFrameButton = document.getElementById('save-frame');
      const finishButton = document.getElementById('finish');
      let currentTool = 'pen';
      let isDrawing = false;
      let currentMove = 'kick';
      const moves = ['kick', 'punch', 'super'];
      let undoStack = [];

      // Create 32x32 pixel grid
      for (let i = 0; i < 32 * 32; i++) {
        const pixel = document.createElement('div');
        pixel.classList.add('pixel');
        pixel.addEventListener('mouseover', (e) => {
          if (e.buttons === 1) {
            draw(e);
          }
        });
        pixel.addEventListener('mousedown', draw);
        grid.appendChild(pixel);
      }

      // Tool selection
      penButton.addEventListener('click', () => {
        currentTool = 'pen';
        updateCursor();
      });
      bucketButton.addEventListener('click', () => {
        currentTool = 'bucket';
        updateCursor();
      });
      eraserButton.addEventListener('click', () => {
        currentTool = 'eraser';
        updateCursor();
      });

      // Drawing functionality
      grid.addEventListener('mousedown', startDrawing);
      grid.addEventListener('mouseup', stopDrawing);
      grid.addEventListener('mouseleave', stopDrawing);
      grid.addEventListener('mouseover', draw);

      function startDrawing(e) {
        isDrawing = true;
        draw(e);
      }

      function stopDrawing() {
        isDrawing = false;
      }

      function draw(e) {
        if (e.buttons !== 1 && e.type !== 'mousedown') return;
        const pixel = e.target;
        if (pixel.classList.contains('pixel')) {
          const oldColor = pixel.style.backgroundColor;
          let newColor;

          if (currentTool === 'pen') {
            newColor = colorPicker.value;
            pixel.style.backgroundColor = newColor;
          } else if (currentTool === 'bucket') {
            newColor = colorPicker.value;
            const initialColor = oldColor || 'rgb(0, 0, 0)';
            floodFill(pixel, initialColor, newColor);
          } else if (currentTool === 'eraser') {
            newColor = '#000000';
            pixel.style.backgroundColor = newColor;
          }

          undoStack.push({ pixel, oldColor, newColor });
        }
      }

      function floodFill(pixel, targetColor, replacementColor) {
        if (pixel.style.backgroundColor === replacementColor) return;
        if (pixel.style.backgroundColor !== targetColor) return;

        pixel.style.backgroundColor = replacementColor;

        const index = Array.from(grid.children).indexOf(pixel);
        const row = Math.floor(index / 32);
        const col = index % 32;

        if (row > 0) floodFill(grid.children[index - 32], targetColor, replacementColor);
        if (row < 31) floodFill(grid.children[index + 32], targetColor, replacementColor);
        if (col > 0) floodFill(grid.children[index - 1], targetColor, replacementColor);
        if (col < 31) floodFill(grid.children[index + 1], targetColor, replacementColor);
      }

      function updateCursor() {
        if (currentTool === 'pen' || currentTool === 'bucket') {
          document.body.style.cursor = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" style="background: ${colorPicker.value};"><circle cx="8" cy="8" r="8" fill="${colorPicker.value}"/></svg>') 8 8, auto`;
        } else if (currentTool === 'eraser') {
          document.body.style.cursor = 'url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'16\' height=\'16\'><rect width=\'16\' height=\'16\' fill=\'white\' /><rect x=\'3\' y=\'3\' width=\'10\' height=\'10\' fill=\'black\' /></svg>") 8 8, auto';
        } else {
          document.body.style.cursor = 'default';
        }
      }

      undoButton.addEventListener('click', () => {
        if (undoStack.length > 0) {
          const lastAction = undoStack.pop();
          lastAction.pixel.style.backgroundColor = lastAction.oldColor;
        }
      });

      saveFrameButton.addEventListener('click', () => {
        const moveData = grid.innerHTML;
        localStorage.setItem(`${currentMove}Move`, moveData);
        currentMove = moves[(moves.indexOf(currentMove) + 1) % moves.length];
        document.getElementById('current-move').textContent = `Current Move: ${currentMove}`;
        grid.innerHTML = localStorage.getItem(`${currentMove}Move`) || '';
      });

      finishButton.addEventListener('click', () => {
        // Save the last move
        const moveData = grid.innerHTML;
        localStorage.setItem(`${currentMove}Move`, moveData);
        
        alert('Fighting moves created successfully! Your character is ready for battle!');
        // Here you would typically save all the move data and proceed to the next step
        // For now, we'll just redirect to a hypothetical battle page
        window.location.href = 'battle-arena.html';
      });

      // Load character sprite
      const characterData = JSON.parse(localStorage.getItem('characterData'));
      if (characterData && characterData.sprite) {
        document.getElementById('character-sprite').innerHTML = characterData.sprite;
      }

      // Initialize with the first move
      document.getElementById('current-move').textContent = `Current Move: ${currentMove}`;

      // Update color picker event listener
      colorPicker.addEventListener('input', updateCursor);
    });
  </script>
</body></html>
