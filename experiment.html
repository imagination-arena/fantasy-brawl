<html><head><base href="https://unpkg.com/" target="_blank" /><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><style>
<style>
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

body {
  font-family: 'Press Start 2P', cursive;
  line-height: 1.6;
  padding: 20px;
  background-color: #4a6ea8;
  color: #000;
  image-rendering: pixelated;
}

h1 {
  color: #fff;
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 2px;
  text-shadow: 2px 2px 0 #ff6b6b, 4px 4px 0 #4ecdc4;
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  padding: 20px;
  font-size: 2.5em;
  background-color: #2c3e50;
  border-radius: 10px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
}

.container {
  display: flex;
  justify-content: space-between;
  max-width: 800px;
  margin: 0 auto;
  background-color: #f0f0f0;
  padding: 20px;
  border: 4px solid #000;
  box-shadow: 0 0 0 4px #f0f0f0, 0 0 0 8px #000;
}

.pixel-editor {
  border: 4px solid #000;
  padding: 20px;
  background-color: #e0e0e0;
}

#pixel-grid {
  display: grid;
  grid-template-columns: repeat(32, 10px);
  grid-gap: 0;
  margin-bottom: 20px;
}

.pixel {
  width: 10px;
  height: 10px;
  background-color: #000;
  border: none;
}

.tools {
  margin-bottom: 20px;
  display: flex;
  justify-content: space-between;
}

.character-info {
  border: 4px solid #000;
  padding: 20px;
  width: 300px;
  background-color: #e0e0e0;
}

input, textarea, button {
  width: 100%;
  margin-bottom: 10px;
  padding: 10px;
  border: 2px solid #000;
  background-color: #f0f0f0;
  color: #000;
  font-family: 'Press Start 2P', cursive;
}

textarea {
  height: 100px;
  resize: vertical;
}

button {
  background-color: #ff6b6b;
  color: #fff;
  border: 2px solid #000;
  cursor: pointer;
  text-transform: uppercase;
}

button:hover {
  background-color: #4ecdc4;
  color: #000;
}

#color-picker {
  height: 40px;
  background-color: transparent;
  border: none;
}

#frames {
  display: flex;
  justify-content: space-around;
  margin-top: 20px;
}

.frame {
  width: 64px;
  height: 64px;
  border: 2px solid #000;
  background-color: #d0d0d0;
}

#next-step {
  margin-top: 20px;
  background-color: #4ecdc4;
  color: #000;
}

#next-step:hover {
  background-color: #ff6b6b;
  color: #fff;
  border-color: #000;
}
</style>
</style></head><body>
  <h1>Create Your Character</h1>
  <div class="container">
    <div class="pixel-editor">
      <div id="pixel-grid"></div>
      <div class="tools">
        <input type="color" id="color-picker" value="#00ffff">
        <button id="pen">Pen</button>
        <button id="bucket">Bucket</button>
        <button id="eraser">Eraser</button>
        <button id="undo">Undo</button>
      </div>
      <div id="frames">
        <canvas class="frame" id="frame1"></canvas>
        <canvas class="frame" id="frame2"></canvas>
        <canvas class="frame" id="frame3"></canvas>
      </div>
      <button id="save-frame">Save Frame</button>
    </div>
    <div class="character-info">
      <input type="text" id="name" placeholder="Character Name">
      <input type="text" id="class" placeholder="Character Class">
      <input type="text" id="stats" placeholder="Character Stats">
      <textarea id="description" placeholder="Character Description"></textarea>
      <button id="randomize">Randomize</button>
      <button id="next-step">Next Step</button>
    </div>
  </div>
  <script>
    const grid = document.getElementById('pixel-grid');
    const colorPicker = document.getElementById('color-picker');
    const penButton = document.getElementById('pen');
    const bucketButton = document.getElementById('bucket');
    const eraserButton = document.getElementById('eraser');
    const undoButton = document.getElementById('undo');
    const saveFrameButton = document.getElementById('save-frame');
    const nextStepButton = document.getElementById('next-step');
    const randomizeButton = document.getElementById('randomize');
    let currentTool = 'pen';
    let isDrawing = false;
    let currentFrame = 0;
    const frames = [document.getElementById('frame1'), document.getElementById('frame2'), document.getElementById('frame3')];
    let undoStack = [];

    // Create 32x32 pixel grid
    for (let i = 0; i < 32 * 32; i++) {
      const pixel = document.createElement('div');
      pixel.classList.add('pixel');
      pixel.addEventListener('mouseover', (e) => {
        if (e.buttons === 1) {
          draw(e);
        }
      });
      pixel.addEventListener('mousedown', draw);
      grid.appendChild(pixel);
    }

    // Tool selection
    penButton.addEventListener('click', () => currentTool = 'pen');
    bucketButton.addEventListener('click', () => currentTool = 'bucket');
    eraserButton.addEventListener('click', () => currentTool = 'eraser');

    // Drawing functionality
    grid.addEventListener('mousedown', startDrawing);
    grid.addEventListener('mouseup', stopDrawing);
    grid.addEventListener('mouseleave', stopDrawing);
    grid.addEventListener('mouseover', draw);

    function startDrawing(e) {
      isDrawing = true;
      draw(e);
    }

    function stopDrawing() {
      isDrawing = false;
    }

    function draw(e) {
      if (e.buttons !== 1 && e.type !== 'mousedown') return;
      const pixel = e.target;
      if (pixel.classList.contains('pixel')) {
        const oldColor = pixel.style.backgroundColor;
        let newColor;

        if (currentTool === 'pen') {
          newColor = colorPicker.value;
          pixel.style.backgroundColor = newColor;
        } else if (currentTool === 'bucket') {
          newColor = colorPicker.value;
          const initialColor = oldColor || 'rgb(0, 0, 0)';
          floodFill(pixel, initialColor, newColor);
        } else if (currentTool === 'eraser') {
          newColor = '#000000';
          pixel.style.backgroundColor = newColor;
        }

        undoStack.push({ pixel, oldColor, newColor });
      }
    }

    // Update color picker event listener
    colorPicker.addEventListener('input', () => {
      if (currentTool === 'pen' || currentTool === 'bucket') {
        document.body.style.cursor = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" style="background: ${colorPicker.value};"><circle cx="8" cy="8" r="8" fill="${colorPicker.value}"/></svg>') 8 8, auto`;
      }
    });

    // Update tool selection to change cursor
    penButton.addEventListener('click', () => {
      currentTool = 'pen';
      updateCursor();
    });
    bucketButton.addEventListener('click', () => {
      currentTool = 'bucket';
      updateCursor();
    });
    eraserButton.addEventListener('click', () => {
      currentTool = 'eraser';
      updateCursor();
    });

    function updateCursor() {
      if (currentTool === 'pen' || currentTool === 'bucket') {
        document.body.style.cursor = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" style="background: ${colorPicker.value};"><circle cx="8" cy="8" r="8" fill="${colorPicker.value}"/></svg>') 8 8, auto`;
      } else if (currentTool === 'eraser') {
        document.body.style.cursor = 'url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'16\' height=\'16\'><rect width=\'16\' height=\'16\' fill=\'white\' /><rect x=\'3\' y=\'3\' width=\'10\' height=\'10\' fill=\'black\' /></svg>") 8 8, auto';
      } else {
        document.body.style.cursor = 'default';
      }
    }

    function floodFill(pixel, targetColor, replacementColor) {
      if (pixel.style.backgroundColor === replacementColor) return;
      if (pixel.style.backgroundColor !== targetColor) return;

      pixel.style.backgroundColor = replacementColor;

      const index = Array.from(grid.children).indexOf(pixel);
      const row = Math.floor(index / 32);
      const col = index % 32;

      if (row > 0) floodFill(grid.children[index - 32], targetColor, replacementColor);
      if (row < 31) floodFill(grid.children[index + 32], targetColor, replacementColor);
      if (col > 0) floodFill(grid.children[index - 1], targetColor, replacementColor);
      if (col < 31) floodFill(grid.children[index + 1], targetColor, replacementColor);
    }

    undoButton.addEventListener('click', () => {
      if (undoStack.length > 0) {
        const lastAction = undoStack.pop();
        lastAction.pixel.style.backgroundColor = lastAction.oldColor;
      }
    });

    saveFrameButton.addEventListener('click', () => {
      const canvas = frames[currentFrame];
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      grid.childNodes.forEach((pixel, index) => {
        const row = Math.floor(index / 32);
        const col = index % 32;
        ctx.fillStyle = pixel.style.backgroundColor || '#000000';
        ctx.fillRect(col * 2, row * 2, 2, 2);
      });
      currentFrame = (currentFrame + 1) % 3;
    });

    nextStepButton.addEventListener('click', () => {
      const characterName = document.getElementById('name').value;
      const characterClass = document.getElementById('class').value;
      const characterStats = document.getElementById('stats').value;
      const characterDescription = document.getElementById('description').value;
      
      if (!characterName || !characterClass || !characterStats || !characterDescription) {
        alert('Please fill in all character information before proceeding.');
        return;
      }
      
      // Save character data
      const characterData = {
        name: characterName,
        class: characterClass,
        stats: characterStats,
        description: characterDescription,
        sprite: grid.innerHTML
      };
      localStorage.setItem('characterData', JSON.stringify(characterData));
      
      // Redirect to the fighting moves page
      window.location.href = 'create-fighting-moves.html';
    });

    randomizeButton.addEventListener('click', () => {
      const classes = ['Netrunner', 'Solo', 'Techie', 'Nomad', 'Rockerboy', 'Corporate'];
      const attributes = ['Strength', 'Speed', 'Defense', 'Special Attack'];
      
      document.getElementById('name').value = generateName();
      document.getElementById('class').value = classes[Math.floor(Math.random() * classes.length)];
            const attributes = ['Strength', 'Speed', 'Defense', 'Special Attack'];
            document.getElementById('stats').value = attributes.map(attr => `${attr}: ${Math.floor(Math.random() * 10) + 1}`).join(', ');
      document.getElementById('description').value = generateDescription();
      
      // Generate random sprite
      generateRandomSprite();
    });

    function generateRandomSprite() {
      const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffffff'];
      const randomColor = colors[Math.floor(Math.random() * colors.length)];
      
      // Clear the grid
      grid.childNodes.forEach(pixel => {
        pixel.style.backgroundColor = '#000000';
      });

      // Draw stick figure
      const stickFigure = [
        // Head
        [15, 5], [16, 5], [14, 6], [15, 6], [16, 6], [17, 6], [14, 7], [15, 7], [16, 7], [17, 7], [15, 8], [16, 8],
        // Body
        [15, 9], [16, 9], [15, 10], [16, 10], [15, 11], [16, 11], [15, 12], [16, 12], [15, 13], [16, 13],
        // Arms
        [13, 10], [14, 10], [17, 10], [18, 10],
        // Legs
        [14, 14], [15, 14], [16, 14], [17, 14], [14, 15], [17, 15]
      ];

      stickFigure.forEach(([x, y]) => {
        const index = y * 32 + x;
        if (grid.children[index]) {
          grid.children[index].style.backgroundColor = randomColor;
        }
      });
    }

    function generateName() {
      const prefixes = ['Mega', 'Retro', 'Pixel', 'Bit', 'Chip', 'Nano', 'Data', 'Glitch'];
      const suffixes = ['Man', 'Bot', 'Warrior', 'Knight', 'Ninja', 'Master', 'Hero', 'Slayer'];
      return prefixes[Math.floor(Math.random() * prefixes.length)] + 
             suffixes[Math.floor(Math.random() * suffixes.length)];
    }

    function generateDescription() {
      const traits = ['Pixelated', 'Glitchy', '8-bit', 'Retro', 'Arcade-style', 'Nostalgic'];
      const backgrounds = ['From a forgotten game', 'Last of their kind', 'Escaped from the arcade', 'Corrupted save file'];
      const goals = ['Defeat the final boss', 'Collect all power-ups', 'Reach the high score', 'Save the princess'];
      
      return `A ${traits[Math.floor(Math.random() * traits.length)]} character ${backgrounds[Math.floor(Math.random() * backgrounds.length)]}. ${goals[Math.floor(Math.random() * goals.length)]}.`;
    }
  </script>
</body></html>

<script>
  // This script will run on the create-fighting-moves.html page
  document.addEventListener('DOMContentLoaded', () => {
    const grid = document.getElementById('pixel-grid');
    const colorPicker = document.getElementById('color-picker');
    const penButton = document.getElementById('pen');
    const bucketButton = document.getElementById('bucket');
    const eraserButton = document.getElementById('eraser');
    const undoButton = document.getElementById('undo');
    const saveFrameButton = document.getElementById('save-frame');
    const finishButton = document.getElementById('finish');
    let currentTool = 'pen';
    let isDrawing = false;
    let currentMove = 'kick';
    const moves = ['kick', 'punch', 'super'];
    let undoStack = [];

    // Create 32x32 pixel grid
    for (let i = 0; i < 32 * 32; i++) {
      const pixel = document.createElement('div');
      pixel.classList.add('pixel');
      pixel.addEventListener('mouseover', (e) => {
        if (e.buttons === 1) {
          draw(e);
        }
      });
      pixel.addEventListener('mousedown', draw);
      grid.appendChild(pixel);
    }

    // Tool selection
    penButton.addEventListener('click', () => currentTool = 'pen');
    bucketButton.addEventListener('click', () => currentTool = 'bucket');
    eraserButton.addEventListener('click', () => currentTool = 'eraser');

    // Drawing functionality
    grid.addEventListener('mousedown', startDrawing);
    grid.addEventListener('mouseup', stopDrawing);
    grid.addEventListener('mouseleave', stopDrawing);
    grid.addEventListener('mouseover', draw);

    function startDrawing(e) {
      isDrawing = true;
      draw(e);
    }

    function stopDrawing() {
      isDrawing = false;
    }

    function draw(e) {
      // ... (same as before)
    }

    // ... (include other functions like floodFill, updateCursor, etc.)

    saveFrameButton.addEventListener('click', () => {
      const moveData = grid.innerHTML;
      localStorage.setItem(`${currentMove}Move`, moveData);
      currentMove = moves[(moves.indexOf(currentMove) + 1) % moves.length];
      document.getElementById('current-move').textContent = `Current Move: ${currentMove}`;
      grid.innerHTML = localStorage.getItem(`${currentMove}Move`) || '';
    });

    finishButton.addEventListener('click', () => {
      // Save the last move
      const moveData = grid.innerHTML;
      localStorage.setItem(`${currentMove}Move`, moveData);
      
      alert('Fighting moves created successfully!');
      // Here you would typically save all the move data and proceed to the next step
    });

    // Load character sprite
    const characterData = JSON.parse(localStorage.getItem('characterData'));
    if (characterData && characterData.sprite) {
      document.getElementById('character-sprite').innerHTML = characterData.sprite;
    }

    // Initialize with the first move
    document.getElementById('current-move').textContent = `Current Move: ${currentMove}`;
  });
</script>
